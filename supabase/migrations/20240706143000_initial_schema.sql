-- Gratitude Bee - Supabase Database Schema
-- Version: 1.0
--
-- This script sets up the initial database schema, including tables for users,
-- events, and dynamic templates, along with the necessary automation.
--

-- 1. =================================================================
--    ENUM TYPES
--    Defines custom types for classifying events and their statuses.
-- =================================================================

CREATE TYPE public.event_type AS ENUM (
    'APPRECIATION',
    'FAVOR_REQUEST',
    'FAVOR_RESPONSE', -- For accepting/declining
    'FAVOR_COMPLETED',
    'HORNET',
    'PING_SENT',
    'PING_RESPONSE',
    'WISDOM',
    'DONT_PANIC'
);

CREATE TYPE public.event_status AS ENUM (
    'PENDING',
    'COMPLETED',
    'ACCEPTED',
    'DECLINED',
    'RESPONDED'
);


-- 2. =================================================================
--    PROFILES TABLE
--    Stores user data, linked to auth.users.
-- =================================================================

CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    display_name text,
    partner_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
    invite_code text UNIQUE NOT NULL,
    expo_push_token text,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable Row Level Security (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
CREATE POLICY "Users can view their own and their partner's profile"
ON public.profiles FOR SELECT
USING (auth.uid() = id OR auth.uid() = partner_id);

CREATE POLICY "Users can update their own profile"
ON public.profiles FOR UPDATE
USING (auth.uid() = id);


-- 3. =================================================================
--    WALLETS TABLE
--    Stores aggregated point totals for performance.
-- =================================================================

CREATE TABLE public.wallets (
    user_id uuid NOT NULL PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    appreciation_points jsonb DEFAULT '{}'::jsonb,
    favor_points integer DEFAULT 20, -- Start users with some points
    hornet_stings integer DEFAULT 0,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable RLS
ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;

-- Policies for wallets table
CREATE POLICY "Users can view their own and their partner's wallet"
ON public.wallets FOR SELECT
USING (auth.uid() = user_id OR user_id = (SELECT partner_id FROM public.profiles WHERE id = auth.uid()));


-- 4. =================================================================
--    EVENTS TABLE (THE LEDGER)
--    The immutable source of truth for all interactions.
-- =================================================================

CREATE TABLE public.events (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    sender_id uuid NOT NULL REFERENCES public.profiles(id),
    receiver_id uuid NOT NULL REFERENCES public.profiles(id),
    event_type public.event_type NOT NULL,
    status public.event_status,
    content jsonb
);

-- Enable RLS
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;

-- Policies for events table
CREATE POLICY "Users can view events they sent or received"
ON public.events FOR SELECT
USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

CREATE POLICY "Users can create their own events"
ON public.events FOR INSERT
WITH CHECK (auth.uid() = sender_id);

CREATE POLICY "Users can update status on events they received"
ON public.events FOR UPDATE
USING (auth.uid() = receiver_id);


-- 5. =================================================================
--    EVENT TEMPLATE TABLES (Admin-managed)
--    These tables define the available actions in the app.
-- =================================================================

CREATE TABLE public.appreciation_badge_templates (
    id text NOT NULL PRIMARY KEY,
    category_id text NOT NULL,
    title text NOT NULL,
    description text,
    bee_count integer DEFAULT 1,
    notification_text text,
    is_active boolean DEFAULT true
);

CREATE TABLE public.favor_templates (
    id text NOT NULL PRIMARY KEY,
    category_id text NOT NULL,
    title text NOT NULL,
    description text,
    points integer DEFAULT 5,
    is_active boolean DEFAULT true
);

CREATE TABLE public.hornet_templates (
    id text NOT NULL PRIMARY KEY,
    title text NOT NULL,
    description text,
    severity text,
    points integer NOT NULL, -- Should be a negative number
    is_active boolean DEFAULT true
);

-- Enable RLS for all template tables
ALTER TABLE public.appreciation_badge_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favor_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.hornet_templates ENABLE ROW LEVEL SECURITY;

-- Policies for template tables
CREATE POLICY "Allow public read-access to all templates"
ON public.appreciation_badge_templates FOR SELECT USING (true);

CREATE POLICY "Admins can manage templates"
ON public.appreciation_badge_templates FOR ALL
USING (auth.jwt()->>'is_admin' = 'true')
WITH CHECK (auth.jwt()->>'is_admin' = 'true');

CREATE POLICY "Allow public read-access to all favor templates"
ON public.favor_templates FOR SELECT USING (true);

CREATE POLICY "Admins can manage favor templates"
ON public.favor_templates FOR ALL
USING (auth.jwt()->>'is_admin' = 'true')
WITH CHECK (auth.jwt()->>'is_admin' = 'true');

CREATE POLICY "Allow public read-access to all hornet templates"
ON public.hornet_templates FOR SELECT USING (true);

CREATE POLICY "Admins can manage hornet templates"
ON public.hornet_templates FOR ALL
USING (auth.jwt()->>'is_admin' = 'true')
WITH CHECK (auth.jwt()->>'is_admin' = 'true');


-- 6. =================================================================
--    AUTOMATION: FUNCTION & TRIGGER FOR NEW USERS
-- =================================================================

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    -- Create a profile and a wallet for the new user
    INSERT INTO public.profiles (id, display_name, invite_code)
    VALUES (NEW.id, NEW.raw_user_meta_data->>'display_name', gen_random_uuid()::text);
    
    INSERT INTO public.wallets (user_id)
    VALUES (NEW.id);
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function when a new user signs up in Auth
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- 7. =================================================================
--    AUTOMATION: FUNCTION & TRIGGER FOR PROCESSING EVENTS
-- =================================================================

CREATE OR REPLACE FUNCTION public.handle_event_points()
RETURNS TRIGGER AS $$
DECLARE
    appreciation_category text;
    points_to_add int;
BEGIN
    -- Update receiver's wallet based on event type
    IF TG_OP = 'INSERT' THEN
        IF NEW.event_type = 'APPRECIATION' THEN
            appreciation_category := NEW.content->>'category_id';
            points_to_add := (NEW.content->>'bee_count')::int;
            UPDATE public.wallets
            SET appreciation_points = jsonb_set(
                appreciation_points,
                ARRAY[appreciation_category],
                (COALESCE(appreciation_points->>appreciation_category, '0')::int + points_to_add)::text::jsonb,
                true -- Create the key if it doesn't exist
            ), updated_at = now()
            WHERE user_id = NEW.receiver_id;
        
        ELSIF NEW.event_type = 'HORNET' THEN
            points_to_add := (NEW.content->>'points')::int; -- This is a negative number
            UPDATE public.wallets
            SET hornet_stings = hornet_stings + points_to_add, updated_at = now()
            WHERE user_id = NEW.receiver_id;

        ELSIF NEW.event_type = 'PING_RESPONSE' THEN
            UPDATE public.wallets
            SET appreciation_points = jsonb_set(
                appreciation_points,
                ARRAY['ping_response'],
                (COALESCE(appreciation_points->>'ping_response', '0')::int + 1)::text::jsonb,
                true
            ), updated_at = now()
            WHERE user_id = NEW.receiver_id; -- The person who responded
        END IF;

    -- Handle updates (e.g., favor completion)
    ELSIF TG_OP = 'UPDATE' THEN
        IF NEW.event_type = 'FAVOR_REQUEST' AND NEW.status = 'COMPLETED' AND OLD.status != 'COMPLETED' THEN
            points_to_add := (NEW.content->>'points')::int;
            -- Award points to the sender of the event (who completed the favor)
            UPDATE public.wallets
            SET favor_points = favor_points + points_to_add, updated_at = now()
            WHERE user_id = NEW.sender_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function after an event is inserted or updated
CREATE TRIGGER on_event_change
AFTER INSERT OR UPDATE ON public.events
FOR EACH ROW EXECUTE FUNCTION public.handle_event_points(); 